다이어트 해야하는 화요일 화이팅
*외래 키랑 연결된 값이 있는 RAW 삭제가 안된다. 삭제하기 위해서는 연결되어있는값을 NULL값으로 주고 삭제 한다.

[오늘 공부 할 것]
-select 문장

#select
;select는 조건을 잘 작성해줘야 한다.

*연산과 함수를 사용하여 새로운 콜럼을 만들 겨우 별칭을 줘야한다. as (별칭) 
//as가 생략이 가능 하다.
//노랑색이 별칭
별칭은 습관으로 붙이는걸로
ex)SELECT ename, sal, sal+nvl(comm,0)as total_sal FROM emp;

*ALL&DISTINCT 의 차이
:ALL 도 DISTINCT 도 모든 정보를 출력이지만
:DISTINCT는 중복을 배제 한다.
SELECT all job FROM emp; //all은 기본 값이어서 입력을 하지 않아도 자동으로 all이 잡힌다.
SELECT DISTINCT deptno FROM emp;

*날짜는 ' '로 처리

*전부 = * 
 ex) SELECT *
 
*AND 와 OR 중에서 AND를 우선적으로 처리한다/
;()처리를 명확하게 하자

1. 조건 
 ⅰ) 컬럼
 ⅱ) 연산자
 -산술 연산자  : +,-,*,/,mod
  *mod : 나머지 연산자 이지만 mod의 결과가 정수가 아닐 수도 있다.
 -비교 연산자	:>,<,>=,<=,=,!=(<>)
 -논리 연산자	:not, and, or
  *AND 연산자가 우선이다 
 -문자열 연산자 : like, || 
  *like : 데이터 안에 무언가가 포함되어 있는지
    ex)
	where ename like 'a%' (a로 시작하는 사원이름)
	where ename like '%s' (s로 끝나는 사원이름)
	where ename like '%to%' (중간에 to가 들어가는 사원이름)
	where ename like '_____' (이름이 5글자인 사원이름)
	where ename like '__S%' (이름에서 3번째가 S인 사원이름)
	where ename like '%L%L%' (이름에서 L이 2번 이상 들어가는 사원의 이름)
  *|| : 문자열 연결 해주는 연산자
   ex) "hi" + "kim" = "hi" || "kim"
  ⅲ)in/between/exists/not
    *not in =>   col name not in (x,y); //col name에 x,y가 아닌 
	*between 사용법 입사일 x날 ~ y날까지
	 ex)where hiredate BETWEEN 'x' AND 'y';//x와 y를 포함
	*not between 
	 ex) col name not between x and y // x~y 사이의 값이 아닌

 ⅳ)IS NULL, IS NOT NULL
  IS NULL : NULL 값이니?
  IS NOT NULL : NULL 값이 아니니?
 ⅴ)함수
 ⅵ)ANY /SOME/ALL
2.정렬
 ORDER BY {column} [ASC or DESC]
 -필요한 경우가 아니면 가급적 회피
 -가장 마지막에 수행
 -null값은 가장 큰 값으로 정렬
 *ASC : 오름차순, 큰수 -> 작은수 
 *DESC : 내림차순, 작은수 -> 큰수
 ex)높은 순서대로 정렬하세요 => 오름차순
 ex)내림차순으로 정리할 때 null값을 맨 마지막에 두고 싶을 때는?
	nvl(column,-1)로 값중에서 가장 작은 수 (지금 경우에는 0) 보다 더 작은 값으로 대치 후 정렬

3.SQL 함수


4.변환 함수
 1)TO_CHAR 
   :number형, date형-> char 형으로 형변환
   *활용 
   //문자의 출력 방식을 정해 줄 수도 있다. (데이터 값은 변하지 않는다.)
    ex)1000000 => 1,000,000 으로 형변환 하고 싶을 때
	TO_CHAR(1000000,'1,000,000')
	ex)오늘의 날의 연도,월,일 요일 출력
	TO_CHAR(sysdate,'yyyy/mm/dd/day)
 2)TO_DATE
	:날짜를 나타내는 문자열을 날짜 형태로 변환하는 함수
 3)TO_NUMBER
	:숫자를 포함한 문자열을 숫자로 변환하는 함수

*like는 속도를 엄청 느리게 한다 사용 자제 합시다잉
*months_between(날짜데이터1,날짜데이터2) 
*정규식 함수 정리하자
*한글 => [가-힣]

 ==========================================================================================
[수수수수수수수 수요일이야 ]0408
*DDL추가문제 캡처 JAVA에서 품
*erd : 데이터베이스 구조 보는 거
 -무료판 설치함
	*연결
	D:\app\Canon\product\11.2.0\dbhome_1\jdbc\lib\ojdbc6.jar //드라이버
	
*오라클 IP 접속
 -sql developer 변경 : localhost -> ip
 -ex ERD 변경 : localhost ->ip

*요일 출력 (날짜 데이터 hiredate가 있음) //date 데이터 (1999/03/04)를 요일 출력//요일출력=문자형 이기에 to_CHAR
TO_CHAR(hiredate,'day')
//day : 출력 '수요일'
//dy : 출력 '수'

*5개씩 급여합계와 인원수를 출력 (rownum이용)
SELECT sum(sal)"급여합계",count(*)"인원수"
FROM emp
GROUP BY ceil(rownum/5);

* 다음과 같이 출력

   CLERK     SALESMAN MANAGER       (업무명)
-----------------------------------------------------------------------
     4           4       3           (인원수)
SELECT count(DECODE(job,'CLERK',1)) CLERK,count(DECODE(job,'SALESMAN',1)) CLERK,count(DECODE(job,'MANAGER',1)) CLERK
FROM emp;

//SELECT 문은 모든 데이터를 받지만 그 안에서 decode로 데이터가 선별된다.
//rownum은 select문에서 출력된는 것에 1부터 숫자를 매긴건데 5로 나누어서 몫이 0일때 5개 나오고,1일 떄 5 개나오니
  5개씩 묶을 수 있다.

*별칭으로 정렬 가능

1.조건함수
 1)decode(expr,search1,result1,search2,result2,search3,result3,[default]) //[ ]생략 가능
   //expr : 데이터, search : if 데이터가 search면 , result : result라고 출력해줘
 ex)
	 SELECT decode(substr(jumin,8,1),'1','남자','2','여자') as gender
	 FROM info_tab;
	 
 2)CASE expr WHEN condition1 THEN result1
			 WHEN condition2 THEN result2
			 ELSE default
	END as 별칭
  :구조가 중요하다!
  ex)
  SELECT  CASE  substr(jumin, 8, 1)
			 WHEN '1' THEN '남자'
			 WHEN'3' THEN '남자'
			 ELSE '여자'
			 END    as gender
  FROM   info_tab;
  
  *테이블 복사
  CREATE TABLE dept AS SELECT * FROM scott.dept
	--복사해왔다 scott계정에서 dept 테이블을
	--제약조건은 다 없어졌다
	--다른건 다필요없고 기본키만 입력해 주자.
	
  *not null 제약 조건 
	ALTER  TABLE   student
	MODIFY (jumin varchar(14) null);
	
 (1)(*)rownum // 오라클에만 있음
	:--데이터의 출력할 때 순서 
	*활용
	WHERE rownum<=5; // 출력 5개만
 (2)집계함수
	:조건으로 선별된 데이터들의 평균, 행의 갯수, 합, 최솟값 ...등
	:NULL 값을 취급하지 않는다.
	*AVG : 평균 
	*count : 행의 갯수
	 -count(*) :조건에 의해 선별된 행의 갯수
	*sum : 합
	*MIN/MAX : 최소값, 최대값
	ex)
	SELECT avg(sal),sum(sal),min(sal),max(sal), count(empno)
	FROM emp
	where job='SALESMAN';
	//job이 SALESMAN인 사람들의 월급의 평균
	*VARIANCE : 분산값
	*STDDEV : 표준편차값
 (3)데이터 그룹
	*두개 이상 동시 그룹화 가능
	*방식(순서)
	SELECT columns  FROM  table_name  WHERE condition
	GROUP BY group_by_expression	
	HAVING condition
	ORDER BY column;
   : SELECT columns 에 집계함수와 grouping 한 값만이 올 수 있다.  
   : groub by 로 그룹화 시켜줌 
   : HAVING 그룹이 만들어졌을 때 그룹을 이용한 조건   
    ex)
	SELECT deptno,round(avg(sal),0),sum(sal)
	FROM emp
	GROUP BY deptno
	HAVING max(sal)>=2900;
	//SELECT deptno (그룹화 한 값 이기에 출력 가능)
	//부서별로 그룹화 (10번 부서, 20번 부서, 30번 부서
 (4)그룹화의 함수
   *ROLLUP
   :결과에 그룹별 합계 정보를 추가 (출력다 하고 밑에)
    ex)GROUP BY ROLLUP(deptno)
   *cube
   :그룹핑 된 컬럼의 합계 정보를 추가 (출력되기 전에 먼저 출력함)
   :ROLLUP 하고 똑같이 사용

 =======================================================================
 0409 [꺄아아아 벌써 목목목요일 기도해라!!! 김나혀니~]
 [오늘 배울거]
 -join(캡처)
 -DB설계 개념 ;(캡처)
 
 *용어
  레이블 : 행
  column : 열
  enitity : oracle에서는 table
  
 1.join
  :공통 칼럼을 이용하여 같은 값을 가지는 행을 연결하여 결과를 생성하는 방법
  : 하나 이상의 테이블로 부터 데이터를 검색 할 때
  : FOREIGN KEY로 연결되어 있어야지 사용 할 수 있다.
  : 단 공통되는 column의 값이 두 테이블 다 null 값일 때 join을 할 수가 없다.
   //FOREIGN 키 생성 조건 다시 살펴 보자 -----------------------------------
  :A 테이블과 B 테이블에  deptno가 공통되는 컬럼 일때 
   A 테이블에 deptno를 사용 하여 B테이블에 같은 deptno를 가진 다른 데이터를 가져온다
  
  *original 방식 = EQUI JOIN 공통칼럼을 '=(EQUAL)'비교를 통해 같은 값을 가진 행과 조인하여 결과 창출
  
  *FROM 위치에 테이블을 줄여서 사용 가능 하다
   ex)
   SELECT e.ename
   FROMM emp e;
   
  0)오류
  *열 오류 : emp에도 dept 에도 있는 col deptno 를 어디 테이블 꺼써? 
   sol) 각 col이 속한 테이블을 지정해 준다. emp.ename
  
  1)내부 join =inner join
  :A와 B 테이블에 공통되는 column이 FOREIGN 키로 연결 되어 있을 때 A,B테이블 둘다 공통되는 column의 값이 null 이 아닐 때
   Ⅰ)original 표현 방식
   ex)
    SELECT emp.ename,emp.deptno,dept.dname
	FROM emp,dept
	WHERE emp.deptno=dept.deptno;
   Ⅱ)JOIN 식 표현 방식
    *inner join 사용
	 방식)
	 SELECT
	 FROM (tabel A) inner join (table B);
     on A의 공통 column = 공통 column
  
  2)외부 join
	:A,B 테이블에  공통되는 column의 값이 둘 중 하나가 null 이지만, 조인 결과로 출력할 필요가 있을 때 사용
	:위 조건이 충족 될 떄 A 또는 B 둘 중에 한 곳에 만 있는 값도 출력 하고 싶을 때 외부 join을 사용 한다.
	:(+) = 해당(공통 columnn에 있는 행) 데이터가 존재하지 않더라도 이를 무시하고 조인에 참여
	:출력하고 싶은  값이 없는 쪽에 (+) 해줘야 한다.
	
   Ⅰ)original 표현 방식
	ex)'WHERE e.deptno=d.deptno(+);'
	* (+)를 어느 쪽에 해줄까? 위치에 차이
	  전제) A , B 에 공통되는 칼럼이 A 나 B 둘중에 한 곳에만 존재 한다.(한 쪽 테이블은 값이 null 이다.)
	  ⅰ)홍길동이라는 사람이 있다. 즉 emp에는 데이터가 있으나 공통 column이 두 테이블 중 한 테이블에 존재하지 않아 가져올데이터를 찾지못한다.	
		//벤다이어 그램 기준 A-B 에만 값이 있는 거 까지 출력 하고 싶을 때
		SELECT e.ename ename,e.deptno deptno ,d.dname dname 
		FROM emp e,dept d
		WHERE e.deptno=d.deptno(+);		
		출력)
		MILLER	10	ACCOUNTING
		KING	10	ACCOUNTING
		CLARK	10	ACCOUNTING
				...
		ALLEN	30	SALES
		홍길동  (null) (null)		
	  ⅱ)operations 이라는 dname 이 있다. 그런데 두 테이블 중 한 테이블에 공통 column이 존재하지 않는다. 
		SELECT e.ename ename,e.deptno deptno ,d.dname dname 
		FROM emp e,dept d
		WHERE e.deptno(+)=d.deptno;
		출력)
		CLARK	10		ACCOUNTING
		KING	10		ACCOUNTING
		MILLER	10		ACCOUNTING
		JONES	20		RESEARCH
				...
		BLAKE	30		SALES
		MARTIN	30		SALES 
		(null) (null)  	OPERATIONS	//dname은 있지만 deptno, e.ename이 null 값이다.	
   Ⅱ)JOIN 식 표현 방식
    : original 방식은 값이 없는 쪽에 (+)를 해줬지만 
	: join 방식은 값이 있어서 더 출력하고 싶은 쪽에 [방향 outer join] 이라고 입력해줍니다.
	ⅰ)left outer join //왼쪽 테이블 의 값이 더 있어서 출력 
	ⅱ)right outer join	//오른쪽 테이블의 값이 더 있어서 출력
  **ⅲ)all outer join // 양쪽에 값을 다 출력 left outer join (합집합) right outer join 출력
  3)연속 join (테이블 3개 이상)
    *공통 column이 각 테이블에 다 있다면 연속 join 방법으로 3개 다 삼각형 형태로 다 쓸 수있다.
	*외부 join을 사용 하고 싶은데 연속 조인 일때는 original로 구성을 짠 후에 그 구성의 순서대로 차근차근 작성해주면 된다.
	--originer 형태
	SELECT e1.first_name||e1.last_name name , e2.first_name||e2.last_name manager_name
	FROM departments d,employees e1,employees e2
	where e1.department_id=d.department_id and e1.manager_id=e2.employee_id(+) and d.department_name='Executive';
	--join 형태
	SELECT e1.first_name||e1.last_name name , e2.first_name||e2.last_name manager_name
	FROM departments d  join employees e1
	on d.department_id = e1.department_id
	left outer join employees e2 
	on e1.manager_id=e2.employee_id
	where d.department_name ='Executive';
   4)self join
    --self join 
	--사원번호, 사원명, 매니저번호,매니저의 이름
	--e1.mgr(매니저 번호) = e2.사원번호
	--emp e1 = 사원 찾는 테이블 e2= 매니저를 찾는 테이블
	*original
	SELECT e1.empno,e1.ename,e1.mgr,e2.ename
	FROM emp e1, emp e2
	WHERE e1.mgr = e2.empno;
	*표준화
	SELECT e1.empno,e1.ename,e1.mgr,e2.ename
	FROM emp e1 inner join emp e2
	on e1.mgr = e2.empno;

=================================================================================
0410
[에헤야디야 금요일]
*join 연습 0410_nanana
*집합 0410_scott

*sql 키워드 복습
1.ddl

2.dml-crud(CREATE(=INSERT)-READ(=SELECT)-UDATE(=UPDATE)-DELETE
	'INSERT INTO 테이블명(컬럼명들) values(값들)
	'UPDATE 테이블명 SET 변경사항 WHERE 조건문 ;
	'DELETE FROM 테이블 명 where 조건문;
	'SELECT 컬럼들 FROM 테이블명 where 조건문;
	
	*Transaction : all or none
	A작업 : A 계좌에서 100원 뺴는 것
	B작업 : B 계좌로 100원을 입금
	;실행 중 문제가 생기면 다시 원래 데이터로 돌려놓는거
	;다 실행이 무사히 완료된걸 확인하고 나서 commit

	*SELECT 구문
	SELECT
	FROM
	WHERE
	GROUP BY
	HAVING
	ORDER BY
	
	*조인 : 1개 이상의 테이블로 부터 정보를 검색할 때
3.dcl
	'GRANT ex) GRANT create table to hr;
	'revte ex) REVOTE create table FROM hr;

	---------------------------------------------------------
1.집합
 UNION 합집합
 UNION ALL 합집합에 중복되는 교집합을 두 번 출력
 INTERSECT 교집합
 MINUS 차집합 
 *select 컬럼수과 반드시 동일
 
 *방식
 SELECT empno, ename, job, deptno FROM emp WHERE job=’CLERK’
 [             ] //[]안에 UNION, UINON ALL, INTERSECT, MINES
 SELECT empno, ename, job, deptno FROM emp WHERE deptno=10;
 
2.서브쿼리
 :하나의 SQL문장 내부에존재하는 또 다른 SELECT 문장
 :DML (SELECT, INSERT, UPDATE, DELETE)에 사용 가능
 *사용방법
 - 서브쿼리는 ( ) 로 묶는다 [권장]
 - 서브쿼리는 연산자의 오른쪽에 [권장]
 - 단일 행인 경우 비교 연산자 가능 ( >, >=, <, <=, =, !=(<>) )
 - 복수 행인 경우 IN, NOT IN, ANY, ALL, EXISTS
 - ORDER BY에선 사용 못한다.
  ;그대신 정렬한 후  정렬한 테이블을 가상의 테이블로 지정해서 사용할 수 있다. 
   ex)
	  -- 월급순으로 상위 10명의명단을 출력
	  -- 월급순으로 정렬한 테이블을 하나의 가상 
		select desc_emp.*
		FROM (SELECT * FROM emp order by nvl(sal,0) desc) desc_emp 
		where rownum <=10;
 ex)
 ⅰ) where 문에 서브쿼리
	--그 평균 급여보다 낮은 급여를 받는 사원의 명단을 조회
	select ename, sal 
	from emp
	where sal < (select round(avg(sal)) from emp );
 ⅱ) From 문에 서브 쿼리
	-- 2)평균 급여보다 높고 최대 급여보다 낮은 월급을 받는 사원의 정보를조회
		SELECT e.*
		FROM emp e,(select round(avg(sal))  avg, max(sal) max from emp ) ext
		where e.sal > ext.avg And e.sal <ext.max;
 ***** 단일 서브쿼리 ( >, >=, <, <=, =, !=(<>) ) 사용	
3.다중 행을 서브쿼리로
  :서브쿼리 결과가 행이 여러개 인경우 
   ex) 부서 10번에 속한 사원번호 => 결과가 행 여러개
  :IN, NOT IN, ANY, ALL, EXISTS		
  ⅰ)IN :반환된 목록의 각각과 비교
  ⅱ)ANY : 비교연산자( >, >=, <, <=, =, !=(<>) ) 와 반환된 목록의 각각과 비교
	//any뒤에 가로 안에있는거 중에 하나라도 비슷한게 있으면 바로 출력
	 ex)
	 SELECT *
		from emp
		where job =any(SELECT job from emp where deptno=10);
  ⅲ)ALL :비교연산자( >, >=, <, <=, =, !=(<>) ) 와 반환된 모든 목록과 비교
  **ALL 과 any에 차이
    --10번 부서의 사람들의 월급 보다 큰 월급을 받는사람 
	-- 10번 부서 사람의 월급이 1000,2000 있을 때  1200월급 받는 사람은 10번부서의 1000월급 받는 사람보다는 크지만 2000 받는 사람보다는 작다.
	-- any는 1200월 급 받는사람을 뽑아내고 
	-- all은 10번 부서의 모든 사랆의 월급보다 커야 한다.  그래서 1200월급받는사람은 출력되지 않는다.
		SELECT *
		from emp
		where job = all(SELECT job from emp where deptno=10);
  ⅳ)EXISTS :적어도 한 개의 행을 리턴하면 true, 그렇지 않으면 false 
	 ex)
		--적어도 한명의 사원으로부터 보고를 받을 수 있는 사원의 정보를
		-- 내 밑에 부하직원이 있다는 거다. 
		-- 사번이 매니저 번호로 있는 즉 매니저로 역활 하고 있는 사원을 뽑아주세요
		--사원번호, 이름, 업무를 출력
		sol)
			SELECT e.empno, e.ename, e.job
			FROM emp e
			WHERE EXISTS (SELECT * FROM emp ext WHERE e.empno=ext.mgr);
		--내가 푸는거 
		//완벽한 답
		Select e1.empno,e1.ename,e1.job
		from emp e1
		where exists (select distinct e1.empno from  emp  e2 where  e1.empno =e2.mgr  ); 
		*주의
		//emp 와 서브 쿼리에 e1, e2 와 전혀 연관 이 없기 때문에 where이 트루든 false든 그냥 전부다 출력한다. 
		Select empno,ename,job
		from emp 
		where exists (select distinct e1.empno from emp e1, emp  e2 where  e1.empno =e2.mgr  ); 
			

[지각한 월요일 다시는 지각 안한다잉]
1.view
2.시퀀스
3.인덱스
---------
4.jdbc


#INSERT / UPDATE / DELETE에서 서브 쿼리 가능
 ⅰ)INSERT
  ->INSERT into table (컬럼이름) values (값);
  :서브쿼리를 값으로 집어 넣어줄때는 values를 사용하지 않는다.
  ex)
	INSERT INTO stat_salary (stat_date,dept_no) 
	select sysdate,deptno from dept ;
 ⅱ )UPDATE
	UPDATE sta_salary s
	set(s.emp_count, s.tot_salary,s.avg_salary)=
		(select count(*),sum(e.sal), round(avg(e.sal),0)from emp.e where e.deptno=s.dept_no group by e.deptno);
    --값을 수정 해줄 때
    --update (테이블 명) set (수정할 column들) = (select 문)
    --select문이 부서별로 그룹화 되어있다. 10번 부서의 평균을 s 테이블 20번 부서의 평균에 집어넣는 것을 방지하기 위해서
    --where e.deptno = s.dept_no 부서 번호가 같은 곳에 사원수, 총액 ,평균 급여를 수정하도록 조건을 꼭 걸어줘야 한다.
  ⅲ)--부서명이 'SALES'인 사원의 정보를 삭제
	DELETE from emp_copy where deptno=(select deptno from dept where dname='SALES');
	
1.뷰(view) : 가상 테이블
  :데이터 보안
  :복잡한 쿼리의 사용빈도가 높은 경우 or 복잡한 조인을 많이 자주 사용하는 경우
  //여러 테이블의 데이터를 가져와서 뷰를 만들었을 때 조인 하지 않고 뷰만 이용하여 여러테이블 데이터 사용 가능
  //실제 우리가 쓰고 있는 테이블이 뷰인지 테이블인지 모름
  :select, insert, delete 다 사용 가능
  :뷰는 가상 테이블이어서 원본의 제약조건 다 따라준다.
**:(주의) 뷰를 삭제 및 수정을 하면 원본에 영향을 미치기 때문에 읽기 전용으로 만들어줘야한다. 
  (#)scott 계정에 뷰 생성 권한을 부여해야 함.
           cmd-> sqlplus “/as sysdba”
           GRANT create view TO scott;
  :뷰 장접
	- View는 데이터베이스의 선택적인 내용을 보여줄 수 있기 때문에 데이터베이스에 대한 액세스를 제한한다
	- 조인을 한 것처럼 여러 테이블에 대한 데이터를 View를 통해 볼 수 있다
	- 한 개의 View로 여러 테이블에 대한 데이터를 검색한다
	- 특정 기준에 따른 사용자 별로 다른 데이터를 액세스 할 수 있다
	
  :뷰 만들기
   ⅰ)읽기 전용 아니게 만들기 
	CREATE OR REPLACE VIEW v_emp AS
	SELECT empno,ename, deptno FROM emp;
   
   ⅱ)읽기 전용으로 만들기(이렇게 만들어줘야함)
   //읽기전용은 INSERT 가 안된다.
	CREATE OR REPLACE VIEW v_emp AS
	SELECT empno,ename, deptno FROM emp with read only;
	
	*or replace : 없으면 만들고 있으면 대치하세요 
	*with read only; :읽기 전용으로 만들어준다.
  :복합 뷰
   - 두 개 이상의 테이블을 조인하여 뷰 작성
   - 입력은 두 테이블이라 안되지만, 예를 들어 사번으로 삭제를 한다면 가능 (단 한쪽 테이블에만 입력하면 들어간다.)
	 INSERT INTO v_emp_info(empno,ename) values(9999,'삼순이');
	 //** 단 뷰에는 입력이 안되고 테이블 안에만 입력이 된다! 

  결론 
  -뷰에 값을 집어넣고 바꾸면 원본 파일도 바뀐다.
  단!!!!! 복합 뷰인 경우 테이블이 2개 이상이기 때문에 값 추가 변경이 안된다.
  단!!!!! 뷰에 하나의 테이블에만 값이 들어가도록 추가해도 테이블에는 값이 들어가지만 뷰에는 값이 들어가지 않는다.
  단!!!!! 원본 테이블의 데이터는 추가가 되기때문에 avg 등 함수의 결과를 뷰로 받을 경우는 view의 값이 바뀐다.
  
  
2. 시퀀스 
 :자동증가수
 :pk를 보통 일련의 번호로 주는 경우가 많아서 pk값을 시퀀스로 지정해주는경우가 많다
 :겹치지 않게 하겠다가 더 중요해서 값이 차례차례가 아니라 뒤죽박죽으로 들어갈 수도 있다.
 -이름 : sequence_테이블명_column명
 
 1)구조 만들기
 CREATE  SEQUENCE   sequence_name
 [ minvalue 1                  -- 시퀀스 최소 숫자
 maxvalue 999999999999 -- 시퀀스 최대 숫자
 increment by 1             -- 증가치
 start with 1                  -- 시작숫자
 nocache                      -- cache를 사용하면 미리 값을 할당하여 조금 빠르게 접근
 noorder                      -- 요청되는 순서대로 값 할당
 nocycle ] ;                    -- 다시 시작할지 여부
 
 ex)
	-- pk가 10000번 부터 시작해서 100 씩 증가하는 번호
	-- pk를 보통 일련의 번호 데이터로 주는데
	-- 시퀀스를 이용해서 자주 번호데이터를 준다.
	CREATE SEQUENCE sequence_temp_no
	start with 10000
	increment by 100;
 
 *시퀀스에 사용되는 의사컬럼
	* 의사컬럼(Pseudocolumns): 테이블에 있는 컬럼처럼 사용되지만 실제로 저장되어 있지 않는 컬럼
   - CURRVAL: 현재 시퀀스 값
	select seq_emp_empno.currval from dual;
	//가상에 테이블에 시퀀스 현재값 집어넣어놓고 값이 몇인지 확인
   
   - NEXTVAL: 다음 생성될 시퀀스 값
   INSERT INTO emp_copy(empno,ename,sal) values(seq_emp_empno.nextval,'홍홍이',3000);
   //다음 생성될 시퀀스 값을 empno라는 값에 주겠음
   
   3.인덱스 (INDEX) - 빠른 검색을 위해
    :PK가 아니면 메모리에 빨리 안올라옴 (pk는 메모리에 올라와있어서 속도가 빠르다)
    :그래서 인덱스를 기본으로 준다.
	//인덱스는 개발자의 영역이 아니다.
	*자동추적 F6 // 권한을 주지 않아 오류가 생김  cmd -> sqlplus "/as sysdba" -> 오류 떳을 때 grant~~~ 복붙
	 : 속도 확인
	
	1)인덱스 만들기
	create index idx_emp_sal  on employees(salary);
	
	2)속도찾기
	select  * from employees
	where salary = 3000; 
	//입력후 자동 추적
	
	3) 만들면 안되는 경우
	 -테이블이 작다
	 -옆이 질의의 조건으로 자주 사용되지 않는다.
	 -대부분의 질의들은 행의 2~4% 이상을 읽어 들일 것으로 예상한다.
	 -테이블은 자주 갱신한다.
	 
========PLSQL 구경하고 입사합시다.
================================
자바&오라클 JAVAJDBC 에서 basic 에서 test

	*준비
	//매번 외부 파일 심어놔야하는데  매번하기 귀차느니 한번에 합시다.
    1.D:\app\Canon\product\11.2.0\dbhome_1\jdbc\lib 파일에 ojdbc6 파일 복사
    2.C:\Program Files\Java\jdk1.8.0_241\jre\lib\ext 여기다가 위에서 복사한 파일 붙여넣기
    //자바에 아예 오라클 라이브러리 지정함
   
   1.자바에서 오라클을 인식하기 위한 DRIVER가 필요해
   //1.드라이버 메모리에 로딩
	/new orcle.jdbc.driver.oracleDriven();
	Class.forName("oracle.jdbc.driver.OracleDriver"); // 문자열이 들어왔을 때 그 문자열이 있는 경로를 불러와서 적용해줌
	
   2.데이터를 주고 받을 가상 통로가 필요합니다. (SOCKET은 이미 가지고 있다.) CONNECTION이 필요해
   Connection con =DriverManager.getConnection("jdbc:oracle:thin:@192.168.0.66:1521:orcl","scott","tiger"); 
   //1번에서 try catch 문이 생김 1번 입력한 줄 바로 다음에 입력합니다.
   //import 해주셔야해요.jdbc:oracle:thin:@192.168.0.66:1521:orcl
   //연결정보
   
   3.SQL문장:SQL 문장을 내가 java에 만들거야
   String sql = "INSERT INTO emp(empno,ename,sal) VALUES(9001,'맹순이',4000)";
   
   4.전송객체 얻어오기 :다짜고짜 전달 안되고 카트가 필요하다 데이터를 실고 이동할 전송객체 얻어오기
   Statement st = con.createStatement();
   
   5.전송 :카트가 실행됨 전송됨(=전송)
    ****중요 구분해
	//-int executeUpdate() : INSERT/UPDATE/DELETE
	//-ResultSet executeQuery() : select //테이블을 resultset에 받아요
	  *ResultSet
	   -객체생성
	   ResultSet rs =st.executeQuery(sql);
	   -함수
	   ResultSet.next :다음 레코드가 있으면 true 없으면 false
	ex)
	//st.executeUpdate() (INSERT,UPDATE,DELETE)
	int result =st.executeUpdate(sql);
    
	//st.executeQuery(sql 문장)
	ResultSet rs =st.executeQuery(sql);
   6.결과확인:카트가 실행한 결과를 우리에게 던져주면 우리가 처리
   ex2)ResultSet 추가 설명
   // ResultSet 이 맨 처음 가리키는건 데이터 값이 아니라 속성을 가리키기에 데이터 출력을 위해선 맨 처음 다음것을 가리키도록 해줘야한다.
		rs.next();
		int result = rs.getInt("COUNT");
		System.out.println("사원 수 :"+result);
   
	ex기본1) 
   //st.executeUpdate() (INSERT,UPDATE,DELETE) + DDL(결과물을 따로 받지 않아서)
   System.out.println(result + "행을 실행합니다.");
   
   -ex기본2)//st.executeQuery(sql 문장)
   while (rs.next()) {
				//출력하는 column(행)의 갯수만큼 syso해서 입력해줌
				System.out.print(rs.getInt("EMPNO") + "\t");//EMPNO값을 얻어오는데 int형으로 자료형 맞추기
				System.out.print(rs.getString("ENAME")+ "\t");
				System.out.print(rs.getInt("SAL")+ "\t");
				System.out.println(rs.getString("JOB"));
			}
   
   ==> 이것만 복사해서 붙여넣기해서 계속 사용
   try {
			Class.forName("oracle.jdbc.driver.OracleDriver");
			
			//2.Connection 얻어오기
			Connection con =DriverManager.getConnection("jdbc:oracle:thin:@192.168.0.66:1521:orcl","scott","tiger");
			
			//3. sql 문장
			String sql = "INSERT INTO emp(empno,ename,sal) VALUES(9001,'맹순이',4000)";
			
			//4. 전송객체 얻어오기
			Statement st = con.createStatement();
			
			//5. 전송
			st.executeUpdate(sql);
			//6. 결과 받기
			st.close();
			con.close();
		
			System.out.println("성공");
		} catch (Exception e) {
			System.out.println("실패");
		} // 문자열이 들어왔을 때 그 문자열이 있는 경로를 불러와서 적용해줌
		
=================================================재일 4/14

04.16 사용자 요구사항
04.17 화면 설계서 + erd
04.20 클래스 다이어그램 + erd 수정본 + 간트차트
==================================================================================
0414 JDBC
JAVA + GUI + DB설계
JDBC 공부 : 캡처 

0.JDBC 어제 복습
 *connection 은 무조건 닫아줘야 한다 오류가 떠도
 //connection은 통로가 하나여서 무조건 닫아줘야지 다른 곳에서 사용 할 수 있다.
  -무조건 실행 구문 finally 에 con.close(); 해줘야한다.
  -그런데 connection con =null;  이 try 구문에서 선언 되있어서 finally에서 사용 할 수 없기에
  -꼭 try 구문 밖에서 꼭 선언 해줘야한다. 
  
 *화면에서 값을 입력받은걸 sql롤 작성할 때
 // 지금은 화면에서 입력 받지 않고 변수에 넣어서 사용하자
 ex)
 String sql = " INSERT INTO emp(empno,ename,sal) "
			+ " VALUES("+empno+",'"+ename +"',"+sal+")";
 //위 방식 어려워서 안쓰고
 //아래 방식 쓸게요.
 String sql = " INSERT INTO emp(empno,ename,sal) "
					+ " VALUES(?,?,?)";
  
  PreparedStatement 사용시 더 간편하게 변수를 이요해서 sql문장에 값을 입력할 수있다.
  //PrepareStatement로 전송 객체가 바뀝니다. ;?가 하나라도 있으면 바로 PrepareStatement  
  1)물음표로 먼저 sql문장 만들고
  String sql = " INSERT INTO emp(empno,ename,sal) "
							+ " VALUES(?,?,?)";
  2)전송객체 만들고 거기에 sql 넣고
  PreparedStatement st = con.prepareStatement(sql);
  3)물읍표에 집어넣을 값 입력
  st.setInt(1, empno);
  st.setString(2, ename);
  st.setInt(3, sal);
  4)5단계 전송 시에 st.executeUpdate()안에 sql을 넣어주면 안된다. 왜냐하면 전송객체 얻어오기에서 sql을 입력했기 때문
   st.executeUpdate();//전송
   
   
   *멤버변수 선언하면 자동 null값 지정 됩니다.
   
1.Info_tab db와 자바를 gui 파일과 연결
 *Drive 연결은 과 테이블 수정은 InfoModelImpl 이라는 클래스에서 합니다. 
 *InfoModelImpl는 InfoModel 인터페이스를 구현 합니다.
 *InfoModel을 인터페이스로 잡은 이유는 oracl 외에도 Mysql 등 다른 데이터베이스에서 사용하기 위해서
 *InfoView 화면을 관리하는데 화면에서 버튼을 눌렀을 때 (show, add, delete 등) 테이블 수정 할 수있도록
  InfoView 안에서 버튼별로 이벤트를 나눠주고 함수를 입력해준다. 
 *InfoVO 테이블이 가지고있는 column을 멤버변수로 갖고 있는데, 테이블 전체를 출력하거나 함수에서 사용하기위해서 덩어리째로 보낼 때 사용
  -InfoVO 수정 법
   ;데이터 입력 방법 1  생성자 함수로 전체 수정
   ;데이터 입력 방법 2 setter 사용하여 하나하나 수정
   ;데이터 출력 방법 getter 사용하여 하나하나 가져옴
   
==================================================
   0416
   JDBC
	model 데이터베이스를 연결하는 것들을 모델이라고 합니다.
	dao jdvc 연결하는 모델
	vo : value object 테이블이 가지고 있는 속성을 가지고있는 인터페이스
   오늘 공부 한거
   1. jdbc의 transection - Acclogic, ACCUI
   
   
---------------------------------------------
   
*자동 커밋 = con.setAutoCommit(false);
   //true일 때 자동 커밋 기능 on, false일 때 자동 커밋 기능 off
   
*Update,delete,insert 일때 실행된 행이 0개 일때는 조건(where)을 찾지 못해서 실행이 안됨.
    -executeUpdate를 사용하는데 executeUpdate는 return값이 실행된 행의 갯수 int형이다.
*Transaction ?
	Data의 처리단위 같은건데, commit이 일어난 시점부터 commit이 이루어지기 전까지의 작업을 하나의
	Transaction이라고 생각하면되.
	
	1)자동 커밋을 false를 준다. 위에있음
	2)Update 와 delete 경우 조건이 틀리면 update,delete가 수행이 안될뿐 결과는 성공이기 때문에 
	조건이 틀렸을 경우에 rollback을 해줘야 한다.
	3)Insert는 입력 되면 성공 안되면 실패 딱 2개의 경우 밖에 없기 때문에 예외만 잡아서 롤백 해주면 된다.

*Rollback의 경우는 Commit과는 반대의 성질로, 최근 실행한 commit부분으로 되돌아 가버리는 명령어야.
	
*jdbc에서 Rollback와 Commit은 connection을 통해서 해준다. 
  con.commint();
  con.rollback();

*패키지가 다른 클래스는 import 시켜줘야 한다.


===========================================================
04/17
제출사항
사용자 요구사항/화면설계서/db설계
클래스 다이어그램
간트차트(일정표)
+git연동
준비물 : 포스트잇


-------------------------------------------
1. Jtable(gui h_jtable)
  : 테이블 형태로 화면에 출력한다.
  : 이벤트는 마우스 이벤트 
  1)Jtable : 화면 담당
  2)MyTableModel extends AbstractTableModel : 데이터 담당
   ① 클래스 만들기 
   :데이터 담당 하는 클래스를 이너 클래스 형태로 하나 만든다. (MyTableModel의 이름이 바뀔수가 있다.)
   ② 만든 클래스에 AbstractTableModel 추상클래스를 상속 받아주기
   :만든 클래스가 Jtable 담당하는 함수입니다를 알려주기 위해서 상속 해준다.
   ③ AbstractTableModel이 추상메소드 이기 때문에 함수들을 오버라이딩 해줘야한다.
    a)열의 갯수를 가져오는 함수 
	public int getColumnCount() {
			return columnName.length;
		}
    b)행의 갯수 가져오는 함수
	public int getColumnCount() {
			return columnName.length;
		}
	c)열의 갯수를 가져오는 함수
	public int getRowCount() {
			return data.size();
		}
	d)row행,column열에 있는 데이터 가져오는 함수
	public Object getValueAt(int rowIndex, int columnIndex) {
						ArrayList temp = (ArrayList) data.get(rowIndex);// rowIndex행의 데이터 전부 가져오기
			return temp.get(columnIndex);// temp는 rowIndex 행의 전부 중 columnIndex열의 데이터를가져옴
		}
	e)컬럼이름 정하기
	public String getColumnName(int c) {
			// 함수중에서 컬럼 이름 정하는 함수가 있는데 내가 지정한 컬럼네임을 가져다 쓰고 싶어서
			// 오버라이딩 합니다.
			return columnName[c];
		}
	f)데이터를 클래스 형태로 바꿈( 목록 => 콤보박스,불린 => 체크박스
	public Class getColumnClass(int c) {
			return getValueAt(0,c).getClass();
		}
	g)편집모드 or 노편집 모드
	public boolean isCellEditable(int row, int col) {
			//true이면 편집모드 false면 노 편집모드
			if(col <2)return true;
			else return false;
		}
	h)지정 위치에 데이터 변경
	public void setValueAt(Object value, int row, int col) {
			ArrayList temp = (ArrayList)data.get(row);
			temp.set(col, value);
			//row,col위치의 셀이 바뀜
			fireTableCellUpdated(row,col);
			}

	④멤버 변수로 선언 + 객체 생성 해준다.
  3)데이터 변경시 
  *table.setModel(myTM);// 혹시모르니 Jtable에 다시 myTM 갔다 붙이기
  *myTM.fireTableDataChanged();// 모델측에서 화면(뷰)한테 내용변경됨을 알려줌


-------------------------------------------
*setEditable : 편집 가능 (boolean)
*setEnable : 절대 건들 수없음 (boolean); 

*시퀀스
CREATE SEQUENCE sequence_movie_movieid
start with 1
increment by 1;

CREATE SEQUENCE sequence_video_videoid
start with 1
increment by 1;

Insert into movie VALUES (SEQUENCE_movie_movieid.nextval,'로맨스','사랑이란','김나현','강동원','두근두근');

INSERT INTO video VALUES( sequence_video_videoid.nextval, SEQUENCE_movie_movieid.currval );